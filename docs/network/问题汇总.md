---
order: 1
---

# 问题汇总

## 网络安全威胁及防范

> 详见[https://eggjs.org/zh-cn/core/security.html](https://eggjs.org/zh-cn/core/security.html)

- XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作。
- CSRF 攻击：伪造用户请求向网站发起恶意请求。
- 钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。
- HTTP 参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。
- 远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。

## 跨域及解决

协议，域名，端口，三者有一不一样，就是跨域。

1. CORS，在服务器端设置几个响应头
2. 在 nginx 等反向代理服务器中设置为同一域名

## Cookies 有哪些字段

> 详见[https://zhuanlan.zhihu.com/p/172533051](https://zhuanlan.zhihu.com/p/172533051)

- name
- value
- domain
- path
- expires/max-age
- size
- httpOnly
- secure
- sameSite
- priority

## 简述建立 TCP 连接的三次握手

![](@images/tcpshaking_1.jpg)

为什么是三次握手？其实是为了验证客户端和服务器是否具备发送、接收、响应能力。

- 第一次握手可以验证 A 的发送能力和 B 的接收能力；
- 第二次握手可以验证 B 的响应、发送能力和 A 的接收能力；
- 第三次握手可以验证 A 的响应能力。

## 简述建立 TCP 连接的四次挥手

![](@images/tcpshaking_2.jpg)

为什么是四次挥手？

- 第一次挥手表达：A 想要断连的意愿，如果 B 数据传完了就通知 A；
- 第二次挥手表达：可能 B 有正在传送的数据，待传送完毕就通知 A；
- 第三次挥手表达：B 数据传送完了，通知 A 可以关闭连接了；
- 第四次挥手表达：告知 B 可以关闭连接了，不用再通知 A 了，A 之后会自行关闭。

为什么第四次挥手时客户端在进入 CLOSED 状态前需要等待 2MSL 时间？

为了保证服务端能收到客户端的确认应答，若客户端发完确认应答后直接进入 CLOSED 状态，那么如果该应答丢失，服务端等待超时（通常为 0.5 秒、1 秒、2 秒…16 秒，远小于 MSL 时间）后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，因此服务端永远无法正常关闭（其实服务端的超时重传次数达到上限后会自动 reset）。而定为 2MSL 是因为应答的往返最大时间就是 2MSL。

备注：

- SYN：synchronous 同步信号。
- ISN：Initial sequence number，初始序列号。
- ACK：acknowledgement 确认信号。
- FIN：finish 结束。
- RST：reset 重置。
- MSL：是 Maximum Segment Lifetime 的缩写，表示报文在网络中的最大生存时间，通常为 120 秒。
- TCB：在两个设备建立连接发送数据之前，双方都必须要先分配内存建立起 TCB 数据块。

## A 记录和 CNAME 记录

> 详见[问答](https://www.zhihu.com/question/22916306)。

A 记录就是把一个域名解析到一个 IP 地址，而 CNAME 记录就是把域名解析到另外一个域名。

为什么有域名？域名的出现是因为比 IP 地址更容易记住。

为什么有 A 记录？因此需要 A 记录保存域名和 IP 地址的映射关系，如果服务器的 IP 地址发生变化就需要修改 A 记录。

为什么有 CNAME 记录？

场景一：

一台服务器 A1 部署了 100 个网站（100 个域名），域名服务器 B 则需要记录 100 个 A 记录，当服务器 A1 迁移到 A2 去了（IP 变了），就需要修改 100 个 A 记录。如果把 100 个域名通过 CNAME 记录指向另一个域名 C，那么域名服务器 B 只需要记录并修改 C 的 A 记录。

那么如果域名 C 变了那不一样要改 100 个 CNAME 记录？IP 变更是常见的情况，而域名 C 是不大会变的。

场景二：

有两个域名 a.me 和 b.me，b.me 指向 145.22.3.116，a.me 指向 b.me，这样看来 a.me 的配置多此一举，直接指向真实的 IP 地址就好了。但是要考虑一个问题，这个 b.me 域名可能不是自己的，那么 b.me 的 IP 地址发生变更时我们无法知情，但是 b.me 这个域名通常是不会改变的。

## TCP 是如何保证可靠性的

> 详见[文章](https://www.pianshen.com/article/57681054083/)。以下是 HTTP/1.x 的情况。

- 校验和：TCP 检验和的计算与 UDP 一样，检验范围包括 TCP 首部及数据部分,但是 UDP 的检验和字段为可选的，而 TCP 中是必须有的。
- 数据的序列号：TCP 将每个字节的数据都进行了编号，这就是序列号。
  - 可以判断数据的完整性
  - 标识数据的顺序，按序解析
  - 有了序列号，就可以批量发送，一次接受确认，提升效率
  - 去除重复数据
- 确认标识 ACK：接受方确认数据完整后会向发送方发送确认信号，发送方收到该信号后就会继续传送数据。当发送发在一定时间内没有收到接收方的确认信号，就会重传。

  ![](@images/tcpack_1.png)
  ![](@images/tcpack_2.png)

- 三次握手和四次挥手
- 流量控制：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快或发送量过大，导致接收端的缓冲区已经满，这时发送方继续发送报文，就会造成丢包，继而引起丢包重传等一系列连锁反应。因此 TCP 支持根据接收端的处理能力，来决定发送端的发送速度和发送量，这个机制叫做流量控制。

  ![](@images/tcpflowcontrol_1.png)

- 拥塞控制：如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此 TCP 引入了慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度和发送量来传送数据。

  ![](@images/tcpslowstart_1.png)

## SSH 的原理

> 详见[文章](https://www.jianshu.com/p/33461b619d53)。

## 网络分层

OSI 七层模型和 TCP/IP 四层模型。

![](@images/osi.png)

以下是 TCP/IP 各层的作用：

- 应用层，浏览器产生 HTTP 请求数据，即 HTTP 报文；
- 传输层，切割 HTTP 报文，并加上 TCP 首部，即 TCP 报文段；
- 网络层，加上 IP 首部，即 IP 数据包；
- 链路层，加上 MAC 地址等以太网首部。

报文实际的加工点在哪？

- 应用层：浏览器
- 传输层：操作系统 TCP 栈
- 网络层：操作系统 IP 栈
- 链路层：网卡驱动程序

视网卡驱动，部分 TCP/IP 字段可能由驱动（硬件）填充，以加速数据包处理。例如 “包校验” 字段。

## TCP 报文数据

![](@images/tcpdata_1.jpg)

## 谈谈 http 协议

HTTP 是基于 TCP/IP 协议之上的应用层无状态协议，定义了 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型，默认端口为 80。

## 谈谈 http 协议的演变

> 详见[文章](https://zhuanlan.zhihu.com/p/26559480)。

![](@images/httpprogress.png)

HTTP/2:

- 二进制分帧：HTTP/2 采用二进制格式（帧）传输数据，而非 HTTP/1.x 的文本格式。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装
- 多路复用（Multiplexing and Concurrency）：代替原来的序列和阻塞机制，同个域名下的 http 请求只需占用一个 TCP 连接，且每个请求都可以带一个 31bit 的优先值，决定哪些资源可以优先传送。HTTP/1.x 中，如果想并发多个请求，必须使用多个 TCP 连接，现代浏览器为了缓解该状况通常会打开多个并行的 TCP 连接，通常是 2-8 个，不同浏览器不同。但这终究只是缓解，并没有真正解决问题。
- 头部压缩（Header Compression）：Http 头压缩后，节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。
- 服务器推送（Server Push）：服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。

雪碧图在 HTTP/2 中还有必要吗？

在 HTTP/1.x 情况下，通过雪碧图集合可以很好的减少请求数量提升加载速度，这毋庸置疑，但在 HTTP/2，在多路复用的前提下，这还有意义吗？请见[这篇文章](https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/)。

备注：

- 多路复用不同于 TTP/1.x 的 keep-alive，keep-alive 本质依然只能同时承载一个 http 请求，只不过延长了 TCP 连接，减少了建立 TCP 连接的次数。

## 知道 http keep-alive 和 tcp keep-alive 吗

http keep-alive 是为了让 tcp 连接活得更久一点，提高 socket 的效率。而 tcp keep-alive 是 TCP 的一种检测 TCP 连接状况的保鲜机制，当连接很久没有数据报文传输时，tcp 自动发送一个数据为空的报文给对方，如果对方回应了这个报文说明还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。

## 简述浏览器发起 url 资源请求的过程

1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；
2. 据这个 IP，找到对应的服务器，发起 TCP 的三次握手建立 TCP 连接；
3. 浏览器发起 HTTP 请求；
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；
5. 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）；
6. 浏览器对页面进行渲染呈现给用户；
7. 关闭 TCP 连接。

## 谈谈 https 协议

HTTPS 协议默认端口为 443，其由 HTTP 和 TLS/SSL 协议组成，其主要目的有三个：

1. 数据保密性：保证数据内容在传输的过程中不会被第三方查看
2. 数据完整性：及时发现被第三方篡改的传输内容
3. 身份校验安全性：保证数据到达用户期望的目的地

浏览器 F12 为什么能看到 HTTPS 的明文？

浏览器 F12 之所以能看到 HTTPS 的明文，是因为浏览器处在应用层，HTTP 协议是应用层协议，而 SSL/TLS 是传输层协议，报文经过了传输层，SSL/TLS 已经对报文进行了解密处理，到达应用层已经是明文。

备注：

- HTTPS 不防止抓包。它防止两件事情：信息泄漏和信息被篡改。
- 常说的 HTTPS 四次握手=TCP 三次握手+SSL 认证（很多步骤当作一次握手）。

## SSL 认证流程是怎么样的？

> 先建立 TCP 连接（三次握手），然后进行 SSL 认证。

![](@images/ssl_1.png)

当第二步客户端发现无效证书时会弹框提醒。

上图的 session key 是干嘛的？

经过 SSL 认证后的数据都会通过 premaster secret 加密后传输，而这个 secret 的交换过程需要经历非对称加密算法，由于非对称加密算法 RSA/DSA 非常耗费 CPU 资源，为了解决这个问题，服务端会把客户端生成的 premaster secret 以 session ID 为索引保存起来，并在 TLS 握手阶段传给客户端，下次客户端再次连接是初始这个 session ID，服务端就能找到对应的 premaster secret，节省性能开销。通常 session ID 寿命只有 1 天，如果在此期间没有新的连接，会被删除。

## 简述 socket

> 由于宏观上 Socket 和 HTTP 都是用来网络通讯的，就很容易让人产生混淆，其实这涉及到一个思维固化问题：“HTTP 是基于 Socket 的，那么 Socket 的一些特性（比如长链接，全双工）HTTP 也应该有”，这是不对的。它们处在不同层，即使 Socket 是长链接的，HTTP 在应用层依然可以表现成短链接。额外参考这个[问答](https://segmentfault.com/q/1010000006809949?_ea=1139974)。

Socket 英文有插座的意思，插座本身就带有连接的特性。

在计算机网络通信领域，Socket 被翻译为“套接字”，Socket 是应用层与传输层间的一个抽象层，是对 TCP/IP 协议的封装，本身不是协议而是一个调用接口（API），我们可以通过调用 Socket 接口来使用 TCP/IP 协议。

网络通讯本质是存在于互联网中的两台计算机内部运行的两个应用程序（进程）在互相通讯，Socket 的诞生就是来负责这个通讯的，Socket 由主机+端口组成。

## 单工、半双工和全双工

- 单工传输只支持数据在一个方向上传输，比如电视、广播。
- 半双工传输允许数据在两个方向上传输，但在同一时刻，只允许数据在一个方向上传输，它实际上是一种可切换方向的单工通信，比如对讲机。
- 全双工通信允许数据同时在两个方向上传输，比如电话通信。

## 谈谈 Mac 地址和 IP 地址

不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用 MAC 地址(硬件地址）。

IP 地址是根据区域分配的，MAC 地址是刻录在网卡中的，当一台计算机有多网卡时，也就意味着有多个 MAC 地址，MAC 地址不会随着机器的地域迁移而改变。IP 地址和 MAC 地址的映射关系基于 ARP 协议，并且每台主机都会在自己的 ARP 缓存区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。

## 谈谈数据流有什么特性

数据流是指“以非常高的速度到来的持续性输入数据”，具有以下特性：

- 有序性（数据到达顺序）
- 无限性（数据流的数据可能无限多）
- 持续性（不同于传统数据的一次性到达）

“数据流只能被读取一次“，因为数据流难以被存储，通常只能在数据第一次到达时获取并解析数据。

## 云服务模型(Cloud Service Model)

![](@images/cloudservice.jpg)

- IaaS(基础架构即服务)：以一个云服务器厂商为例，如果它只给用户提供一个宿主机，所有配置都需要自行配置，包括操作系统也要自行安装，那么它就属于 IaaS
- PaaS(平台即服务)：如果它提供一个现成的运行时环境，不能安装软件，比如已经安装好操作系统，配置好 Java 开发运行环境，专门针对 Java 用户的，那么它就属于 PaaS
- FaaS(函数即服务)：FaaS 是 PaaS 能力的一种缩放，缩放到 Function 级别，比如 AWS Lambda
- SaaS(软件即服务)：如果它提供一个现成的软件，用户只需注册账号就能使用，比如百度网盘，那么它就属于 SaaS
- BaaS(后端即服务)：BaaS 服务商为客户(开发者)提供整合云后端的服务，如提供文件存储、数据存储、推送服务、身份验证服务等功能，以帮助开发者快速开发应用
- DaaS(数据即服务)
- NaaS(网络即服务)

## 谈谈 Serverless <Badge>待补充</Badge>

特指无服务感知，而并非无服务，可以理解为 FaaS+BaaS。

## ARP 协议（Address Resolution Protocol）

> ARP 协议是根据 IP 地址获取物理地址的一个 TCP/IP 协议，在 TCP/IP 模型中属于 IP 层，在 OSI 模型中属于链路层。

当主机 A 欲向某个主机 B 发送数据时：

会先在本地的 ARP 缓存区中查找目标 IP 地址（如果不在同一局域网，则会依靠网络拓扑找寻），然后检查是否存在对应的 MAC 地址，如果有则直接在数据包中加上目的 MAC 地址，然后通过网络将该 MAC 帧发往此硬件地址；

如果没有找到，就向本地网段发起一个 ARP 请求的广播包，此 ARP 请求包含了发送端主机的 IP 地址、MAC 地址和目标主机的 IP 地址，网络中的所有主机收到这个 ARP 请求后，会检查是否自己就是这个目标主机，如果是则回应并将 ARP 请求所携带的发送端主机的 IP 地址和 MAC 地址映射关系更新到本地 ARP 缓存中，不是则忽略。这一切都是基于信任的，所以事实上会存在 ARP 虚假回应。发送端主机收到回应后也会更新本地的 ARP 缓存。

### 网络拓扑（Network Topology）

网络中的传输都是基于网络拓扑的，网络拓扑会有不同的结构形式，有总线形拓扑、星形拓扑、环形拓、树形拓扑以及混合形拓扑，一个网关管辖着一块区域的主机，而这个网关又相当于上级网关的主机，这些网关 IP 都是基于地域分配的，每台主机第一次请求都会向自己的默认网关发起，层层向上，之所以强调第一次请求，是因为网络拓扑其实是个寻址的过程，在理想情况下，某次成功的请求是可以被缓存下来的，那么下次请求就无需层层向上查找目的地了。

## 什么是 CDN

## 什么是流

一般来说，“流”指的是不能随机读取只能按顺序读取的序列。
