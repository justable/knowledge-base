---
order: 1
---

# 问题汇总

## 常见名词

- NAT：网络地址转换（Network Address Translation）
- ISP：互联网服务提供商（Internet Service Provider）
- IPV4：互联网协议第四版（Internet Protocol Version 4）
- VLSM：可变长子网掩码（Variable Length Subnetwork Mask）
- IANA：互联网数字分配机构（The Internet Assigned Numbers Authority）

## 网络安全威胁及防范

> 详见[https://eggjs.org/zh-cn/core/security.html](https://eggjs.org/zh-cn/core/security.html)

- XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作（前端的责任）。

主要解决办法是前端对输入来源做安全字符串过滤，比如通过 HTML 转义特殊字符。

- CSRF 攻击：伪造用户请求向网站发起恶意请求（服务端的责任）。比如：
  - 用户 Alice 登录访问某有 csrf 漏洞的银行网站http://www.examplebank.com。
  - Alice 被某些信息诱导访问危险网站 B。
  - 危险网站 B 上有一个 img 标签`<img src="http://www.examplebank.com/from=Alice&amount=100&to=Bob">`
  - 这个 img 标签的 src 不指向图片，而是一个 http 请求，这个请求让银行服务器从 Alice 转 100 到 Bob 账户上，由于 Alice 已经登录，浏览器发请求时候会带上 cookie 骗取服务器信任得到响应。
  - 这样 Alice 的钱就被悄悄转走了。

img 请求不会触发跨域，所以 cors 也无法防范。解决方法有：1、设置 cookie 的 same-site 属性；2、内置隐藏变量，每次请求需要携带该隐藏变量并与后端 session 中的相匹配才行；3、服务端通过 referer 检查请求来源地址。

- 钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。
- HTTP 参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。
- 远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。

## 跨域及解决

协议，域名，端口，三者有一不一样，就是跨域。

1. CORS，在服务器端设置几个响应头
2. 在 nginx 等反向代理服务器中设置为同一域名

## Cookies 有哪些字段

> 详见[https://zhuanlan.zhihu.com/p/172533051](https://zhuanlan.zhihu.com/p/172533051)

- name
- value
- domain
- path
- expires/max-age
- size
- httpOnly
- secure
- sameSite
- priority

## A 记录和 CNAME 记录

> 详见[问答](https://www.zhihu.com/question/22916306)。

A 记录就是把一个域名解析到一个 IP 地址，而 CNAME 记录就是把域名解析到另外一个域名。

为什么有域名？域名的出现是因为比 IP 地址更容易记住。

为什么有 A 记录？因此需要 A 记录保存域名和 IP 地址的映射关系，如果服务器的 IP 地址发生变化就需要修改 A 记录。

为什么有 CNAME 记录？

场景一：

一台服务器 A1 部署了 100 个网站（100 个域名），域名服务器 B 则需要记录 100 个 A 记录，当服务器 A1 迁移到 A2 去了（IP 变了），就需要修改 100 个 A 记录。如果把 100 个域名通过 CNAME 记录指向另一个域名 C，那么域名服务器 B 只需要记录并修改 C 的 A 记录。

那么如果域名 C 变了那不一样要改 100 个 CNAME 记录？IP 变更是常见的情况，而域名 C 是不大会变的。

场景二：

有两个域名 a.me 和 b.me，b.me 指向 145.22.3.116，a.me 指向 b.me，这样看来 a.me 的配置多此一举，直接指向真实的 IP 地址就好了。但是要考虑一个问题，这个 b.me 域名可能不是自己的，那么 b.me 的 IP 地址发生变更时我们无法知情，但是 b.me 这个域名通常是不会改变的。

## SSH 的原理

> 详见[文章](https://www.jianshu.com/p/33461b619d53)。

## 网络分层

OSI 七层模型和 TCP/IP 四层模型。

![](@images/osi.png)

以下是 TCP/IP 各层的作用：

- 应用层，浏览器产生 HTTP 请求数据，即 HTTP 报文；
- 传输层，切割 HTTP 报文，并加上 TCP 首部，即 TCP 报文段；
- 网络层，加上 IP 首部，即 IP 数据包；
- 链路层，加上 MAC 地址等以太网首部。

报文实际的加工点在哪？

- 应用层：浏览器
- 传输层：操作系统 TCP 栈
- 网络层：操作系统 IP 栈
- 链路层：网卡驱动程序

视网卡驱动，部分 TCP/IP 字段可能由驱动（硬件）填充，以加速数据包处理。例如 “包校验” 字段。

## 谈谈 http 协议

HTTP 是基于 TCP/IP 协议之上的应用层无状态协议，定义了 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型，默认端口为 80。

## 谈谈 http 协议的演变

> 详见[文章](https://zhuanlan.zhihu.com/p/26559480)。

![](@images/httpprogress.png)

HTTP/2:

- 二进制分帧：HTTP/2 采用二进制格式（帧）传输数据，而非 HTTP/1.x 的文本格式。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装
- 多路复用（Multiplexing and Concurrency）：代替原来的序列和阻塞机制，同个域名下的 http 请求只需占用一个 TCP 连接，且每个请求都可以带一个 31bit 的优先值，决定哪些资源可以优先传送。HTTP/1.x 中，如果想并发多个请求，必须使用多个 TCP 连接，现代浏览器为了缓解该状况通常会打开多个并行的 TCP 连接，通常是 2-8 个，不同浏览器不同。但这终究只是缓解，并没有真正解决问题。
- 头部压缩（Header Compression）：Http 头压缩后，节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。
- 服务器推送（Server Push）：服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。

雪碧图在 HTTP/2 中还有必要吗？

在 HTTP/1.x 情况下，通过雪碧图集合可以很好的减少请求数量提升加载速度，这毋庸置疑，但在 HTTP/2，在多路复用的前提下，这还有意义吗？请见[这篇文章](https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/)。

备注：

- 多路复用不同于 TTP/1.x 的 keep-alive，keep-alive 本质依然只能同时承载一个 http 请求，只不过延长了 TCP 连接，减少了建立 TCP 连接的次数。

## 知道 http keep-alive 和 tcp keep-alive 吗

http keep-alive 是为了让 tcp 连接活得更久一点，提高 socket 的效率。而 tcp keep-alive 是 TCP 的一种检测 TCP 连接状况的保鲜机制，当连接很久没有数据报文传输时，tcp 自动发送一个数据为空的报文给对方（心跳检测包），如果对方回应了这个报文说明还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。

## 简述浏览器发起 url 资源请求的过程

1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；
2. 据这个 IP，找到对应的服务器，发起 TCP 的三次握手建立 TCP 连接；
3. 浏览器发起 HTTP 请求；
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；
5. 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）；
6. 浏览器对页面进行渲染呈现给用户；
7. 关闭 TCP 连接。

## 简述 socket

> 由于宏观上 Socket 和 HTTP 都是用来网络通讯的，就很容易让人产生混淆，其实这涉及到一个思维固化问题：“HTTP 是基于 Socket 的，那么 Socket 的一些特性（比如长链接，全双工）HTTP 也应该有”，这是不对的。它们处在不同层，即使 Socket 是长链接的，HTTP 在应用层依然可以表现成短链接。额外参考这个[问答](https://segmentfault.com/q/1010000006809949?_ea=1139974)。

Socket 英文有插座的意思，插座本身就带有连接的特性。

在计算机网络通信领域，Socket 被翻译为“套接字”，Socket 是应用层与传输层间的一个抽象层，是对 TCP/IP 协议的封装，本身不是协议而是一个调用接口（API），我们可以通过调用 Socket 接口来使用 TCP/IP 协议。

网络通讯本质是存在于互联网中的两台计算机内部运行的两个应用程序（进程）在互相通讯，Socket 的诞生就是来负责这个通讯的，Socket 由主机+端口组成。

## 单工、半双工和全双工

- 单工传输只支持数据在一个方向上传输，比如电视、广播。
- 半双工传输允许数据在两个方向上传输，但在同一时刻，只允许数据在一个方向上传输，它实际上是一种可切换方向的单工通信，比如对讲机。
- 全双工通信允许数据同时在两个方向上传输，比如电话通信。

## 谈谈 Mac 地址和 IP 地址

不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用 MAC 地址(硬件地址）。

IP 地址是根据区域分配的，MAC 地址是刻录在网卡中的，当一台计算机有多网卡时，也就意味着有多个 MAC 地址，MAC 地址不会随着机器的地域迁移而改变。IP 地址和 MAC 地址的映射关系基于 ARP 协议，并且每台主机都会在自己的 ARP 缓存区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。

## 谈谈数据流有什么特性

数据流是指“以非常高的速度到来的持续性输入数据”，具有以下特性：

- 有序性（数据到达顺序）
- 无限性（数据流的数据可能无限多）
- 持续性（不同于传统数据的一次性到达）

“数据流只能被读取一次“，因为数据流难以被存储，通常只能在数据第一次到达时获取并解析数据。

## 云服务模型(Cloud Service Model)

![](@images/cloudservice.jpg)

- IaaS(基础架构即服务)：以一个云服务器厂商为例，如果它只给用户提供一个宿主机，所有配置都需要自行配置，包括操作系统也要自行安装，那么它就属于 IaaS
- PaaS(平台即服务)：如果它提供一个现成的运行时环境，不能安装软件，比如已经安装好操作系统，配置好 Java 开发运行环境，专门针对 Java 用户的，那么它就属于 PaaS
- FaaS(函数即服务)：FaaS 是 PaaS 能力的一种缩放，缩放到 Function 级别，比如 AWS Lambda
- SaaS(软件即服务)：如果它提供一个现成的软件，用户只需注册账号就能使用，比如百度网盘，那么它就属于 SaaS
- BaaS(后端即服务)：BaaS 服务商为客户(开发者)提供整合云后端的服务，如提供文件存储、数据存储、推送服务、身份验证服务等功能，以帮助开发者快速开发应用
- DaaS(数据即服务)
- NaaS(网络即服务)

## 谈谈 Serverless <Badge>待补充</Badge>

特指无服务感知，而并非无服务，可以理解为 FaaS+BaaS。

## ARP 协议（Address Resolution Protocol）

> ARP 协议是根据 IP 地址获取物理地址的一个 TCP/IP 协议，在 TCP/IP 模型中属于 IP 层，在 OSI 模型中属于链路层。

当主机 A 欲向某个主机 B 发送数据时：

会先在本地的 ARP 缓存区中查找目标 IP 地址（如果不在同一局域网，则会依靠网络拓扑找寻），然后检查是否存在对应的 MAC 地址，如果有则直接在数据包中加上目的 MAC 地址，然后通过网络将该 MAC 帧发往此硬件地址；

如果没有找到，就向本地网段发起一个 ARP 请求的广播包，此 ARP 请求包含了发送端主机的 IP 地址、MAC 地址和目标主机的 IP 地址，网络中的所有主机收到这个 ARP 请求后，会检查是否自己就是这个目标主机，如果是则回应并将 ARP 请求所携带的发送端主机的 IP 地址和 MAC 地址映射关系更新到本地 ARP 缓存中，不是则忽略。这一切都是基于信任的，所以事实上会存在 ARP 虚假回应。发送端主机收到回应后也会更新本地的 ARP 缓存。

### 网络拓扑（Network Topology）

网络中的传输都是基于网络拓扑的，网络拓扑会有不同的结构形式，有总线形拓扑、星形拓扑、环形拓、树形拓扑以及混合形拓扑，一个网关管辖着一块区域的主机，而这个网关又相当于上级网关的主机，这些网关 IP 都是基于地域分配的，每台主机第一次请求都会向自己的默认网关发起，层层向上，之所以强调第一次请求，是因为网络拓扑其实是个寻址的过程，在理想情况下，某次成功的请求是可以被缓存下来的，那么下次请求就无需层层向上查找目的地了。

## 什么是 CDN

## 什么是流

一般来说，“流”指的是不能随机读取只能按顺序读取的序列，本质是 TCP 的分包机制的宏观描述。
