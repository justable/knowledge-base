# HTTPS 知识汇总

## 谈谈 https 协议

HTTPS 协议默认端口为 443，其由 HTTP 和 TLS/SSL 协议组成，其主要目的有三个：

1. 数据保密性：保证数据内容在传输的过程中不会被第三方查看，非对称加密（RSA/ECC/DH）和对称加密（AES/DES/RC4）。
2. 数据完整性：及时发现被第三方篡改的传输内容，散列算法（MD5/SHA）。
3. 身份校验安全性：保证数据到达用户期望的目的地，基于 CA 的数字签名证书。

备注：

- HTTPS 不防止抓包。它防止两件事情：信息泄漏和信息被篡改。
- 常说的 HTTPS 四次握手=TCP 三次握手+SSL 认证（很多步骤当作一次握手）。

## TLS 前言

> 以下描述统称非对称加密为公钥私钥，对称加密为密钥。TLS 是 SSL 的替代方案。

为了解决 HTTP 的明文传输，HTTPS 决定将传输内容进行加密，问题来了，服务器把数据加密后，客户端如何读懂这些数据呢？这时服务器必须要把密钥告诉客户端，但是，服务器如果将这个密钥以明文的方式给客户端，还是会被中间人截获，依然无法保证通信的保密性。但是如果服务器以密文的方式将密钥发给客户端，客户端又如何解开这个密文得到其中的密钥呢？

这时，我们引入了非对称加解密的概念，在传输数据之前增加一个密钥协商环节，服务端将公钥以明文的方式传给客户端，客户端接收公钥后对密钥进行加密，然后传输给服务器，服务器再通过私钥解密得到密钥，至此双方的密钥就同步了。可能有人会问为什么不全程非对称加解密呢？这是因为非对称加解密的效率比较低且 CPU 占用率高。

不过问题又来了，假如在在客户端和服务端之间有个中间人，拦截了密钥协商环节服务器发送的公钥，并将自己的公钥传给客户端，客户端将密钥通过假的公钥加密后发送给服务器，此时该中间人又拦截到，并用自己的私钥解码得到了密钥，然后用之前拦截的正确的公钥加密该密钥传送给服务器，此后客户端和服务端都通过该密钥进行传输数据，此中间人就可以获得所有数据。过程如下图所示：

![](@images/tls_middle_attack.jpg)

为了解决此问题，我们引入了数字证书的概念。服务器首先生成公私钥，将公钥提供给相关机构（CA），CA 将公钥放入数字证书并将数字证书颁布给服务器，此时服务器就不是简单的把公钥给客户端，而是给客户端一个数字证书，数字证书中加入了一些数字签名的机制，保证了数字证书一定是服务器给客户端的。中间人想拦截数字证书替换其中的公钥生成并发送伪造的证书，但该伪造的证书不能够获得 CA 的认证，此时客户端和服务器就知道通信被劫持了。加入了 CA 数字签名认证的 TLS 会话过程如下所示：

![](@images/tls_ca.jpg)

## TLS 具体过程

> 具体过程分析参考“使用 Wireshark 分析 HTTPS 连接过程”一文。下图第二步客户端发现无效证书时会弹框提醒。

![](@images/ssl_1.png)

1. TCP 三次握手，之后都是 TLS 过程。
2. 客户端发起 Client Hello，交代自身的一些信息，比如支持哪些算法之类的，包括一个随机数 RandomC（明码）。
3. 服务端发起 Server Hello，包括一个随机数 RandomS（明码）。交代了从 Client 提供的支持集里最终的选择，我们可以在 nginx 配置的 ssl_ciphers（加密套件类型）参数中告诉服务器如何选择。接着服务端还会发送自己的证书，根据 TLS 加密套件不同，会影响之后的交流环节，比如基于 RSA 算法的密钥协商，Client 会从证书提取公钥并完成证书的身份验证；本实验是基于 ECDHE 算法的，证书只用来让 Client 做身份验证，其中不包含公钥，之后会额外发送 Server Key Exchange 数据包来传递公钥。要注意如果服务端需要对客户端进行验证，在客户端收到服务端的 Server Hello 消息之后，首先需要向服务端发送客户端的证书，让服务端来验证客户端的合法性。
4. Server Key Exchange，这步是可选的，如果证书中没有携带公钥，则会在这步传输公钥
5. Client Key Exchange，传送前客户端会对服务端的证书进行有效性验证，通过后就会生成用于数据加密的密钥。生成过程是：客户端此时已经持有了 RandomC 和 RandomS，并使用数据包的 ECDHE 参数（包含公钥）生成 Pre-Master Secret，和 RandomC 和 RandomS 共同生成对称密钥的种子 Master Secret，Master Secret 作为数据加解密相关的 secret 的 Key Material 的一部分。Key Material 的计算跟 Master Secret(Key) 的计算类似，只不过计算的次数要更多。Key Material 需要计算 12 次，从而产生 12 个 hash 值。产生 12 个 hash 之后，紧接着就可以从这个 Key Material 中获取 Session Secret（Session Key）了，Session Secret 就是最终用来对数据进行加解密的。需要注意，在此之前的所有 TLS 握手信息都是明文传送的。在收到服务端的证书等信息之后，客户端会使用一些加密算法(例如：RSA, Diffie-Hellman)产生一个 48 个字节的 Key，这个 Key 叫 PreMaster Secret，很多材料上也被称作 PreMaster Key, 最终通过 Master secret 生成 session secret， session secret 就是用来对应用数据进行加解密的。PreMaster secret 属于一个保密的 Key，只要截获 PreMaster secret，就可以通过之前明文传送的随机数，最终计算出 session secret，所以 PreMaster secret 使用 RSA 非对称加密的方式，使用服务端传过来的公钥进行加密，然后传给服务端。
6. 服务端也使用上一步客户端同样的方式生成 Session Secret，至此密钥协商就结束了，之后就可以使用这个 Session Secret 对数据进行加密传输了。

## 涉及到的密码

上面的分析和讲解主要是为了突出握手的过程，所以 PreMaster secret，Master secret，session secret 都是一代而过，但是对于 Https，SSL/TLS 深入的理解和掌握，这些 Secret Keys 是非常重要的部分。所以，准备把这些 Secret Keys 抽出来单独分析和讲解。

- PreMaster secret（预主密码）：PreMaster secret 是在客户端使用 RSA 或者 Diffie-Hellman 等加密算法生成的。它将用来跟服务端和客户端在 Hello 阶段产生的随机数结合在一起 生成 Master secret。在客户端使用服务单的公钥对 PreMaster secret 进行加密之后传送给服务端，服务端将使用私钥进行解密得到 PreMaster secret。也就是说服务端和客户端都有一份相同的 PreMaster secret 和随机数。PreMaster secret 前两个字节是 TLS 的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在 Client Hello 阶段，客户端会发送一份加密套件列表和当前支持的 SSL/TLS 的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者 很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的 PreMaster 版本号 跟之前 Client Hello 阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。

- Master secret（Shared Secret）：上面已经提到，由于服务端和客户端都有一份相同的 PreMaster secret 和随机数，这个随机数将作为后面产生 Master secret 的种子，结合 PreMaster secret，客户端和服务端将计算出同样的 Master secret。Master secret 是有系列的 hash 值组成的，它将作为数据加解密相关的 secret 的 Key Material。
- Session Secret：在中断重连场景中，为了避免重新握手，每次请求对话都携带上 SessionID，如果服务器存有此 SessionID 记录的话，双方就可以重新使用已有的对称密钥而不必重新生成一把。但这种服务器缓存的策略在分布式的负载均衡场景上就无法正常运行。于是在 TLS1.3 中没有了 SessionID 这种会话恢复模式不过为了兼容性依然保留了这个字段。session_ticket 就是为了解决 SessionID 这个问题的，目前只有 Firefox 和 Chrome 浏览器支持。同时它也负责对数据进行加解密，它就是对称密钥。

## 数字签名证书

证书由公钥、证书主体、数字签名等内容组成（所有我在阿里云购买的 DV 证书签发成功后会得到 key 和 pem 文件，但是自签名过程是怎么样的？）。

申请者拿到 CA 的证书并部署在网站服务器端，那浏览器发起握手并接收到证书后，如何确认这个证书就是 CA 签发的呢？怎样避免第三方伪造这个证书？答案就是数字签名（digital signature）。数字签名是证书的防伪标签，目前使用最广泛的 SHA-RSA（SHA 用于哈希算法，RSA 用于非对称加密算法）。数字签名的制作和验证过程如下：

1. 数字签名的签发。首先是使用哈希函数对待签名内容进行安全哈希，生成消息摘要，然后使用 CA 自己的私钥对消息摘要进行加密。

2. 数字签名的校验。使用 CA 的公钥解密签名，然后使用相同的签名函数对签名证书内容进行签名，并和服务端数字签名里的签名内容进行比较，如果相同就认为校验成功。

需要注意的是：

1. 数字签名签发和校验使用的非对称密钥是 CA 自己的公钥和私钥，跟证书申请者（提交证书申请的公司实体）提交的公钥没有任何关系。

2. 数字签名的签发过程跟公钥加密的过程刚好相反，即是用私钥加密，公钥解密。（一对公钥和私钥，公钥加密的内容只有私钥能够解密；反过来，私钥加密的内容，也就有公钥才能够解密）

3. 现在大的 CA 都会有证书链，证书链的好处：首先是安全，保持 CA 的私钥离线使用。第二个好处是方便部署和撤销。这里为啥要撤销呢？因为，如果 CA 数字证书出现问题（被篡改或者污染），只需要撤销相应级别的证书，根证书依然是安全的。

4. 根 CA 证书都是自签名，即用自己的公钥和私钥完成了签名的制作和验证。而证书链上的证书签名都是使用上一级证书的非对称密钥进行签名和验证的。

5. 怎样获取根 CA 和多级 CA 的密钥对？还有，既然是自签名和自认证，那么它们是否安全可信？这里的答案是：当然可信，因为这些厂商跟浏览器和操作系统都有合作，它们的根公钥都默认装到了浏览器或者操作系统环境里。

## 自签名证书的生成

需要注意的是接下来几种文件的类型：

- key 是服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端接收到数据的解密
- csr 是证书签名请求文件（公钥），用于提交给证书颁发机构（CA）对证书签名
- crt 是由证书颁发机构（CA）签名后的证书，或者是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息
- keystore 包含证书的文件，可以自己去导入证书
- PEM 文件格式存储证书和密钥，用于导出，导入证书时候的证书的格式，有证书开头，结尾的格式。

还有就是 X.509 是一个标准，规范了公开秘钥认证、证书吊销列表、授权凭证、凭证路径验证算法等。

具体过程待补充。

## 数据完整性验证

数据传输过程中的完整性使用 MAC 算法来保证。为了避免网络中传输的数据被非法篡改，或者数据比特被污染，SSL 利用基于 MD5 或 SHA 的 MAC 算法来保证消息的完整性（由于 MD5 在实际应用中存在冲突的可能性比较大，所以尽量别采用 MD5 来验证内容一致性）。 MAC 算法是在密钥参与下的数据摘要算法，能将密钥和任意长度的数据转换为固定长度的数据。发送者在密钥的作用下，利用 MAC 算法计算出消息的 MAC 值，并将其添加在需要发送的消息之后，并发送给接收者。接收者利用同样的密钥和 MAC 算法计算出消息的 MAC 值，并与接收到的 MAC 值比较。如果二者相同，则报文没有改变；否则，报文在传输过程中被修改或者污染，接收者将丢弃该报文。 SHA 也不能使用 SHA0 和 SHA1，山东大学的王小云教授（很牛的一个女教授，大家有兴趣可以上网搜索一下她的事迹）在 2005 年就宣布破解了 SHA-1 完整版算法，并获得了业内专家的认可。微软和 google 都已经宣布 16 年及 17 年之后不再支持 sha1 签名证书。

## 制作自签证书

https://www.cnblogs.com/zhaobowen/p/13321578.html

## 小结

在 Wireshark 实际抓包中，会遇到部分和书本资料描述不一致的地方，这应该是和 TLS 版本，或者选择的 TLS 加密套件类型有关。比如非对称密钥协商算法是 DHE/ECDHE(EC Diffie-Hellman) 会有 Server Key Exchange 这一步，如果是 RSA/DH/ECDH 算法则不会有 Server Key Exchange 这一步。因此当自己使用 Wireshark 实践中与书本介绍的连接过程有出入时不要惊讶，也许就是中间的算法策略选择，TLS 版本等因素所影响。

TLS 过程中任何决定都会有协商过程，比如算法选择，加密方法等，协商过程都类似发送方发一个支持的集合，接收方选择其中一个。

## FAQ

- Session Secret 是用来对数据进行加解密，还负责恢复 Session？

- 浏览器 F12 为什么能看到 HTTPS 的明文？

浏览器 F12 之所以能看到 HTTPS 的明文，是因为浏览器处在应用层，HTTP 协议是应用层协议，而 SSL/TLS 是传输层协议，报文经过了传输层，SSL/TLS 已经对报文进行了解密处理，到达应用层已经是明文。

- 如果是自签名的证书，浏览器如何来解析的？

自签名证书始终是遵循 TLS 协议的证书，一切都是合法的，只是颁发机构并非在受信任的 CA 中。只要系统或浏览器将根证书设置为信任，浏览器是不会告警的。

在使用 CA 证书的过程中，浏览器会用 CA 的公钥解密签名，这个 CA 公钥应该是预制在系统或者浏览器内部的。如果是自签名的证书，用什么公钥去解密签名呢？难道是用的自签名证书内部携带的非对称加密公钥么？

ca 证书并非只有一个，你系统内置了多个权威机构的根证书，例如握手阶段服务端告诉你它的证书机构是 a.b，那么客户端会去系统信任的列表里找 a.b 的证书，并使用该证书的公钥进行计算。
同理，只要你把自签名的根证书安装(导入)到系统，并设为信任。那么客户端会请求操作系统判断及获取该证书的公钥。参考 12306 或一些银行要求你安装他们的证书的场景。

- server key exchange 是什么？

http://bbs.chinaunix.net/thread-4150877-1-1.html

我知道 client key exchange 是用服务器证书 rsa 公钥加密传输预主密钥。但是 server key exchange 是干嘛的呢？

server key exchange 不是必须的，跟你加密预主密钥使用的算法有关。对于 RSA 算法来说，certificate message 中包含了足够的信息，client key exchange 可以使用这些信息加密预主密钥。但是对于 DH 这类的算法来说，certificate message 只包含了部分信息，剩余的信息在 server key exchange 中。你看贴的图里面使用的就是 EC Diffie-Hellman 算法。

也就是说，采用 DH 算法，证书仅仅是用来验证身份的，而非用来提取公钥，然后加密预主密钥的？

对，是这样的。单纯使用 RSA 算法时，RSA 算法既用来验证服务器的身份，也用来加密预主密钥。单纯采用 DH 算法时，DH 算法只用来加密预主密钥，没办法验证服务器身份，称为 anonymous DH。DH 算法还可以跟 RSA 算法一起使用，RSA 验证服务器身份，DH 算法加密预主密钥。

## 参考

[深入揭秘 HTTPS 安全问题&连接建立全过程](https://zhuanlan.zhihu.com/p/22142170)
[TLS 握手协商流程解析](https://blog.csdn.net/phunxm/article/details/72853552)
[HTTPS 过程以及详细案例](https://www.cnblogs.com/helloworldcode/p/10104935.html)
[SSL 详解](https://www.cnblogs.com/NathanYang/p/9183300.html)
[SSH2 协议的交互细节](https://www.yuque.com/barretlee/network/ssh2)
[Https(SSL/TLS)原理详解](http://www.rosoo.net/a/201409/17051.html)
[TLS/SSL 协议详解 (30) SSL 中的 RSA、DHE、ECDHE、ECDH 流程与区别](https://blog.csdn.net/mrpre/article/details/78025940)
