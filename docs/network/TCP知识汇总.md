# TCP 知识汇总

> 报文通常是在 HTTP 层的概念，TCP 应该叫作 TCP 报文段。在应用层到传输层过程当中，HTTP 报文会被切分成多个报文段，每个报文段加上 TCP 首部就组成了 TCP 报文段了。TCP 报文段 = TCP 包。

## 简述建立 TCP 连接的三次握手

![](@images/tcpshaking_1.jpg)

为什么是三次握手？其实是为了验证客户端和服务器是否具备发送、接收、响应能力。

- 第一次握手可以验证 A 的发送能力和 B 的接收能力；
- 第二次握手可以验证 B 的响应、发送能力和 A 的接收能力；
- 第三次握手可以验证 A 的响应能力。

## 简述建立 TCP 连接的四次挥手

![](@images/tcpshaking_2.jpg)

为什么是四次挥手？

- 第一次挥手表达：A 想要断连的意愿，如果 B 数据传完了就通知 A；
- 第二次挥手表达：可能 B 有正在传送的数据，待传送完毕就通知 A；
- 第三次挥手表达：B 数据传送完了，通知 A 可以关闭连接了；
- 第四次挥手表达：告知 B 可以关闭连接了，不用再通知 A 了，A 之后会自行关闭。

为什么第四次挥手时客户端在进入 CLOSED 状态前需要等待 2MSL 时间？

为了保证服务端能收到客户端的确认应答，若客户端发完确认应答后直接进入 CLOSED 状态，那么如果该应答丢失，服务端等待超时（通常为 0.5 秒、1 秒、2 秒…16 秒，远小于 MSL 时间）后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，因此服务端永远无法正常关闭（其实服务端的超时重传次数达到上限后会自动 reset）。而定为 2MSL 是因为应答的往返最大时间就是 2MSL。

备注（区分大小写）：

- SYN：synchronous 同步信号。
- ISN：Initial sequence number，初始序列号。
- ACK：acknowledgement 确认信号，1 表示接收成功，0 表示没有接收，通常第一次发送时为 0 或者接收失败时为 0。
- ack：ack=上一次对方最后一个报文段 A 的 seq 值+ A 的数据部分长度 TCP Payload Len（数据包总长度），这样规定一方面是可以证明我方接收的数据是完整的，另一方面是告知对方下次发送的第一个报文段头部的 seq 值设置为该值。占 4 字节。[TCP Payload 和 TCP segment 的区别](https://ask.wireshark.org/question/3498/what-is-the-difference-between-tcp-payload-and-tcp-segment-data/?answer=3512#post-id-3512)。TCP Payload = TCP 头部（即被协议解析消耗掉的部分）+ TCP Segment？【标记点一】
- seq：表示的是当前 TCP 报文段的第一个字节在此次 HTTP 报文数据流所处的位置，这样对方才能按照顺序重组报文分包。它占 4 字节，序号增加到 2^32-1 后，下个序号又回到 0。TCP 数据包中的序列号（Sequence Number）不是以报文分段来进行编号的，而是将连接生存周期内传输的所有数据当作一个字节流，序列号就是整个字节流中每个字节的编号。
- FIN：finish 结束。
- RST：reset 重置。
- MSL：是 Maximum Segment Lifetime 的缩写，表示报文在网络中的最大生存时间，通常为 120 秒。
- TCB：在两个设备建立连接发送数据之前，双方都必须要先分配内存建立起 TCB 数据块。
- Win：负责流量控制，接收端处理数据的速度是有限的，如果发送方发送数据的速度过快或发送量过大，导致接收端的缓冲区已经满，这时发送方继续发送报文，就会造成丢包，继而引起丢包重传等一系列连锁反应。所以发送方会根据接收方的上次回复报文中的 Win 字段来决定此次发送的总数据量。
- PDU：Protocol Data Unit

## TCP 是如何保证可靠性的

> 详见[文章](https://www.pianshen.com/article/57681054083/)。以下是 HTTP/1.x 的情况。

- 校验和：TCP 检验和的计算与 UDP 一样，检验范围包括 TCP 首部及数据部分,但是 UDP 的检验和字段为可选的，而 TCP 中是必须有的。
- 数据的序列号：TCP 将每个字节的数据都进行了编号，这就是序列号。
  - 可以判断数据的完整性
  - 标识数据的顺序，按序解析
  - 有了序列号，就可以批量发送，一次接受确认，提升效率
  - 去除重复数据
- 确认标识 ACK：接受方确认数据完整后会向发送方发送确认信号，发送方收到该信号后就会继续传送数据。当发送发在一定时间内没有收到接收方的确认信号，就会重传。

  ![](@images/tcpack_1.png)
  ![](@images/tcpack_2.png)

- 三次握手和四次挥手
- 流量控制：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快或发送量过大，导致接收端的缓冲区已经满，这时发送方继续发送报文，就会造成丢包，继而引起丢包重传等一系列连锁反应。因此 TCP 支持根据接收端的处理能力，来决定发送端的发送速度和发送量，这个机制叫做流量控制。

  ![](@images/tcpflowcontrol_1.png)

- 拥塞控制：如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此 TCP 引入了慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度和发送量来传送数据。

  ![](@images/tcpslowstart_1.png)

## TCP 报文段数据

![](@images/tcpdata_1.jpg)

TCP 报文段首部占 20 个字节。

### 报文分包大小策略

mtu 是网络传输最大报文包，mss 是网络传输数据最大值。

具体分析如下：

1、mss 加包头数据就等于 mtu. 简单说拿 TCP 包做例子。 报文传输 1400 字节的数据的话，那么 mss 就是 1400，再加上 20 字节 IP 包头，20 字节 tcp 包头，那么 mtu 就是 1400+20+20. 当然传输的时候其他的协议还要加些包头在前面，总之 mtu 就是总的最后发出去的报文大小。mss 就是你需要发出去的数据大小。

2、MSS: Maxitum Segment Size 最大分段大小 2.MSS 最大传输大小的缩写，是 TCP 协议里面的一个概念。 3.MSS 就是 TCP 数据包每次能够传输的最大数据分段。

3、为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，这个值 TCP 协议在实现的时候往往用 MTU 值代替（需要减去 IP 数据包包头的大小 20Bytes 和 TCP 数据段的包头 20Bytes）所以往往 MSS 为 1460。通讯双方会根据双方提供的 MSS 值得最小值确定为这次连接的最大 MSS 值。

## FAQ

- 【标记点一】处如果刚好最后一个 TCP 报文段接收到了，中间的丢包了，如果按照标记点一的 Ack 计算法，那就发现不了了啊？

TCP 协议是靠 Seq 验证数据完整性的，所以标记点一的说法是不正确的，Ack 并不是验证数据的完整性的。

- 一个 TCP 报文段包括首部和数据部分，那么 HTTP 头部分包时是单独的一个 TCP 报文段吗？

- seq 占 4 个字节，当 HTTP 报文数据总长度大于 2^32-1 个字节时，如何描述当前 TCP 报文段所处的位置呢？网上说是下个序号又回到 0，那重回的 0 和第一次的 0 怎么区分呢？

- Wireshark 抓包时，多个连续的 TCP 报文段，会出现第一个 TCP 包的 Len=0，这是什么包？

这是 ACK 包，用来应答对方的上次请求的，ACK 包都单独一个 TCP 报文段。在 TCP 中，每个数据分包接收方都会回复一个 ACK 包，哪怕都是重复的，保证通信的健壮性。TCP 提供的确认机制，可以在通信过程中不对每一个 TCP 数据包发出单独的 ACK 包（Delayed ACK 机制），而是在传送数据时，顺便把 ACK 信息传出，这样可以大大提高网络的利用率和传输效率。

- HTTP/2 的若干新特性，对于 TCP 协议来讲有感知吗？比如 HTTP/2 的二进制分帧，多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
