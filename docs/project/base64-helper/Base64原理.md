# Base64 原理

> 它是编码方式而不是加密方式。

Base64 取自 ASCII 码的其中 64 个字符，如下图所示：

![](@images/base64.png)

它的本质是将二进制数据每 6bit 转化为这 64 个字符。对文件的 Base64 编码和对字符串的 Base64 编码没有本质区别，只不过字符串会先通过 ASCII 转换成二进制数据（字符串文本的存储），而文件则通过对于的软件程序以二进制的格式存储在计算机中。

## Base64 的由来

Base64 是为了在纯文本场景中表示非文本数据的。

举个例子，HTTP 协议是纯文本协议，它要求请求的首行和请求头都必须是 ASCII 编码（当然也有传输二进制数据的 MIME type），我们通过 Wireshark 的抓包也能验证这一点，如下图所示：

![](@images/wireshark.png)

选中的字节数组是`[68,65,56,6c,6c,6f,0a]`，这里的字节是以十六进制表示的，先转换成十进制，再对应 ASCII 码表就可得到数据就是`['h','e','l','l','o','\n']`。但如果想要传递一张 png 图片呢？图片属于非文本数据，从某种意义上来讲，非文本数据在纯文本场景中是不可见的，但是任何文件在计算机中都可以用二进制数据表示，那么就可以将图片的原始二进制数据（即 01 组合）进行 ASCII 转码了，其中 0 对应的 ASCII 码的十六进制是 30，1 对应的是 31，假如一张图片的原始二进制数据为`1010`，那么在请求报文中就表示为`[31,30,31,30]`，请求到达终端后再解析即可。但是这带来的问题是数据膨胀，即使是一张 1kb 的图片，请求报文也需要很长篇幅才能表述它。

为了解决二进制字符串过长的问题，就诞生了 Base64，Base64 规定以 6bit 一组将二进制数据转化为 ASCII 字符串，这样非文本文件就可以用 Base64 文本来表示了，并且相对于“二进制字符串表示非文本文件”这一方法节省了 6 倍的空间。但是对于字符串或纯文本文件来说，本身就可以用 ASCII 字符串表示，使用了 Base64 字符串后反而变得更长了，4 个 Base64 字符（4×6bit）只能表示 3 个 ASCII 字符（3×8bit）。

此时又产生了新的疑惑，为什么 Base64 选取了 ASCII 码中的 64 个字符？先说结论，这是权衡存储长度、字符可见行、和 8 的最小公倍数后的结果。

**对于节省存储长度来讲**，当然是 BaseXX 越大越好，但是肯定不能超出 ASCII 码的范围，即 Base256。

**对于字符可见行来讲**，ASCII 码中有 33 个控制字符（如换行符、回车符等打印后不可见的符号）和后 128 个扩展 ASCII 码（扩展码在不同国家的显示有兼容问题），那么只剩下了 95 个所谓的可见字符，考虑到最后需要二进制表示，6bit 是控制在 95 之内的最大位数了，即 Base64。

**对于和 8 的最小公倍数来讲**，其实从上面两个点来考虑 Base64 已经是最优方案了，至于为什么和 8 的最小公倍数越小越好，则是为了考虑和 ASCII 码的兼容性，3 个 ASCII 字符恰好能用 4 个 Base64 字符表示，7 个 ASCII 字符恰好能用 8 个 Base128 字符表示，公倍数越小，触发补 0 的几率就越小，什么是补 0 下文会有讲解。

**要注意 Base64 只能转译二进制数据和 ASCII 字符串，不能转译中文**，需要先将中文进行 utf-8 编码，比如使用 encodeURIComponent 方法，然后再进行 Base64 转译。

## 实现原理

对于二进制数据转 Base64 就很直接了，每 6bit 转换成 10 进制再去 Base64 索引表查询对应的字符即可。对于 ASCII 字符串转 Base64 需要中转以下，先查出字符对应的 ASCII 序号，再转换成二进制，再每 6bit 转换成 10 进制再去 Base64 索引表查询对应的字符即可。看下面这个例子：

![](@images/base64_hey.png)

再看一个不是 6 和 8 公倍数的例子：

![](@images/base64_h.png)

在转码时，Base64 规定不足 6bit 的低位补 0，并且 Base64 字符串长度得是 4 的倍数，不足的在末尾补充=号。

在解码时，Base64 字符串对应的二进制位数应是 8 的倍数，因为 6bit 的 Base64 需要解码成 8bit 的 ASCII，如果不能被 8 整除就不能精确的对应到 ASCII 字符了，但是 Web API 中的 atob 在解码遇到不能被 8 整除的情况时有两种解决方式，如果小于 8 则报错，如果大于 8 且不能被 8 整除则忽略多余的位数，这就导致了不同的 Base64 字符串解码后可能得到相同的 ASCII 码，我猜测原因可能是解码是为转码服务的，只要保证能对转码后的结果进行还原就可以了。

> [base64 特性导致的不等串解码相同](https://www.jianshu.com/p/0d7c41aded0c)

```js
btoa('He') === 'SGU=';
// 010010 00'0110 0101'00
atob('SGU=') === 'He';
// 010010 00'0110 0101'01
atob('SGV=') === 'He';
// 010010 00'0110 0101'10
atob('SGW=') === 'He';
// 010010 00'0110 0101'11
atob('SGX=') === 'He';
```
