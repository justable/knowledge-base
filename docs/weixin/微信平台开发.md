# 微信平台开发

## 注意点

- 主体是指实名认证的个人或企业

- 微信开放平台和小程序 C 绑定意味这什么？

- 微信开发者工具中的云环境是登录账号所对应的腾讯云的云环境，比如 publicA

- 一个微信公众平台账号只能对应一个小程序或者一个公众号

- 同一开放平台账号下的公众号和应用，只有一个 UnionID

- 查看云环境，https://console.cloud.tencent.com/minigamecloud/env/overview

- 同一个邮箱只能绑定微信产品的一种帐号

1）已绑定开放平台的邮箱；
2）已绑定个人微信的邮箱；
3）已绑定企业号的邮箱；
4）已绑定订阅号、服务号的邮箱；
5）已绑定小程序的邮箱。

- 一个手机号码只能注册 5 个公众帐号

## UnionId,OpenId,AppId 的区别

![](@images/weixin_wxid.png)

在一个开放平台账户下，可以绑定小程序，公众号等多个程序应用，UnionId 是一个开放平台下的唯一标识，可以跨多个程序应用使用；OpenId 是每个程序应用的用户的唯一标识，不同程序应用下的用户的 OpenId 不同；AppId 是标识一个程序应用的，不同的程序应用的 AppId 不同，比如腾讯云、小程序、开放平台都会有独立的 AppId。

## 云开发小程序

具体流程参考[云开发小程序](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/quickstart.html)。

[项目配置](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)
[全局配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)
[页面配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)

### 控制台

在开发者工具点击**云开发**菜单可以查看并管理云端环境内容，包括数据库、云函数、用户访问情况等。云端环境有唯一的环境 ID 标识，一个小程序中默认配额可以创建两个环境。

### 数据库

具体介绍参考[数据库使用文档](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database.html)。

云开发采用的是文档型数据库，数据库 API 分为小程序端和服务端，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。

下面是小程序端 API 使用样例，

```js
// 1. 获取数据库引用
const db = wx.cloud.database();
// 2. 构造查询语句
db.collection('books')
  .where({
    publishInfo: {
      country: 'United States',
    },
  })
  .get({
    success: function(res) {
      // 输出 [{ "title": "The Catcher in the Rye", ... }]
      console.log(res);
    },
  });
```

### 云存储

具体介绍参考[云存储](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/storage.html)

云开发提供了一块存储空间，提供了上传文件到云端、带权限管理的云端下载能力，开发者可以在小程序端和云函数端通过 API 使用云存储功能。在小程序端可以分别调用 wx.cloud.uploadFile 和 wx.cloud.downloadFile 完成上传和下载云文件操作。

下面是存储文件的样例，

```js
// 让用户选择一张图片
wx.chooseImage({
  success: chooseResult => {
    // 将图片上传至云存储空间
    wx.cloud.uploadFile({
      // 指定上传到的云路径
      cloudPath: 'my-photo.png',
      // 指定要上传的文件的小程序临时文件路径
      filePath: chooseResult.tempFilePaths[0],
      // 成功回调
      success: res => {
        console.log('上传成功', res);
      },
    });
  },
});
```

### 数据库权限相关

具体参考[数据库权限管理](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/security-rules.html)

### 云函数

具体使用介绍参考[云函数指引](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html)。如需在云函数中操作数据库、管理云文件、调用其他云函数等操作，可使用官方提供的 npm 包 [wx-server-sdk](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-server-api/) 进行操作。还可以[云函数本地调试](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/local-debug.html)。

云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。小程序内提供了专门用于云函数调用的 API。开发者可以在云函数内使用 wx-server-sdk 提供的 getWXContext 方法获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。

下面是云函数的样例，

```js
// index.js 是入口文件，云函数被调用时会执行该文件导出的 main 方法
// event 包含了调用端（小程序端）调用该函数时传过来的参数，同时还包含了可以通过 getWXContext 方法获取的用户登录态 `openId` 和小程序 `appId` 信息
const cloud = require('wx-server-sdk');
exports.main = (event, context) => {
  let { userInfo, a, b } = event;
  let { OPENID, APPID } = cloud.getWXContext(); // 这里获取到的 openId 和 appId 是可信的
  let sum = a + b;

  return {
    OPENID,
    APPID,
    sum,
  };
};
```

## 组件库

官方组件库 weui，有两种版本，

1. 类似 bootstrap 的纯样式组件，使用时只需引入样式文件，[仓库地址](https://github.com/Tencent/weui-wxss/)
2. 类似 antd 的组件，每个组件有自身结构，使用时需要引入整个组件，[仓库地址](https://github.com/wechat-miniprogram/weui-miniprogram)

具体使用参考[weui](https://developers.weixin.qq.com/miniprogram/dev/extended/weui/)。

## button 的 open-type

基础组件 button 的 open-type 可以自动发起一些常见的 api 请求，比 bindtap 手动调用 api 更便捷。具体参考[button 的 open-type](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)。

- contact: 打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息
- share: 触发用户转发，使用前建议先阅读使用指引
- getPhoneNumber: 获取用户手机号，可以从 bindgetphonenumber 回调中获取到用户信息
- getUserInfo: 获取用户信息，可以从 bindgetuserinfo 回调中获取到用户信息
- launchApp: 打开 APP，可以通过 app-parameter 属性设定向 APP 传的参数具体说明
- openSetting: 打开授权设置页
- feedback: 打开“意见反馈”页面，用户可提交反馈内容并上传日志，开发者可以登录小程序管理后台后进入左侧菜单“客服反馈”页面获取到反馈内容

## 插件和自定义组件的区别

插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。相对于普通 js 文件或自定义组件，插件拥有更强的独立性，拥有独立的 API 接口、域名列表等，但同时会受到一些限制，如一些 API 无法调用或功能受限。还有个别特殊的接口，虽然插件不能直接调用，但可以使用 插件功能页 来间接实现。同时，框架会对小程序和小程序使用的每个插件进行数据安全保护，保证它们之间不能窃取其他任何一方的数据（除非数据被主动传递给另一方）。

## globalData 的定位

我的第一印象是和 react 的 redux 相同，其实不然，globalData 提供了跨 page 共享数据的能力，但是不具备数据的响应式能力，即无法触发视图更新。

## setData 的渲染机制

setData 类似 react 的 setState，但又不同。react 运行在浏览器上注定是单线程模型，为了节省渲染开销，react 会合并 setState；小程序是有逻辑线程和渲染线程的，setData 其实是从逻辑线程传送数据到渲染线程，实时进行视图渲染，直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。

![](@images/wx_page_lifecycle.png)

View Thread 是渲染线程，AppService Thread 是逻辑线程，initial data 就是在 page 中定义的 data 属性。

可以在 onLoad 中调用 setData 来初始化数据，此时还没有发生第一次渲染。

onLoad 只会发生一次，而 onShow 每次进入页面都会发生。

## 生命周期

App 的生命周期是相对整个小程序的，Page 的生命周期则是对于一个页面。

- onLoad：初次加载触发，只会触发一次
- onShow：页面显示在当前屏幕上时触发，每次切换页面都会触发
- onReady：初次加载初始数据渲染完毕时触发，只会触发一次
- onHide：相对于 onShow
- onUnload：相对于 onLoad

## DarkMode 配置

具体参考[DarkMode 适配指南](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/darkmode.html)。

## 使用 npm 安装扩展组件时

package.json 要在 project.config.js 定义的 miniprogramRoot 内，没有配置 miniprogramRoot 时，miniprogramRoot 就是 project.config.js 所在的目录。

1. 执行 npm install
2. 工具 --> 构建 npm
3. 勾选“使用 npm 模块”选项

之所以要进行构建 npm，是因为小程序打包时不会把 node_module 中的文件打包进去，而是通过构建 npm，生成 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。

小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。

寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。

小程序 npm 包是指专为小程序定制的 npm 包，目录如下所示:

```
|--node_modules
|    |--testComp // 小程序 npm 包
|    |    |--package.json
|    |    |--src
|    |    |--miniprogram_dist
|    |         |-index.js
|    |         |-index.json
|    |         |-index.wxss
|    |         |-index.wxml
|    |--testa // 其他 npm 包
|         |--package.json
|         |--lib
|         |    |--entry.js
|         |--node_modules
|              |--testb
|                   |--package.json
|                   |--main.js
|--pages
|--app.js
|--app.wxss
|--app.json
|--project.config.js
```

具体使用参考[npm 支持](https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html)。

## 分包和预下载

把小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。每个使用分包小程序必定含有一个主包。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而分包则是根据开发者的配置进行划分。

分包又分为普通分包和独立分包，普通分包依赖主包，当进入普通分包页面时会先下载主包，普通分包的初衷是所见主包的体积，把一部分代码以按需加载的形式分离出来；独立分包不依赖主包，能够独立运行，可以把部分独立的功能分离到独立分包中，这样进入独立分包的页面就无需加载主包和普通分包。

具体参考[分包加载](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html)。

## 数据预拉取和周期性更新

这两个功能可以放在一起讲，都需要在小程序管理后台配置相应的服务端接口。

数据预拉取，小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度。具体参考[数据预拉取](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/pre-fetch.html)。

周期性更新，即使用户没有打开小程序，也会周期性每隔 12 个小时从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间，增强在弱网条件下的可用性。具体参考[周期性更新](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/background-fetch.html)。

两者使用流程类似，

```js
App({
  onLaunch() {
    wx.setBackgroundFetchToken({
      token: 'xxx',
    });
    wx.getBackgroundFetchData({
      // fetchType: "periodic",
      // fetchType: "pre",
      success(res) {
        console.log(res.fetchedData); // 缓存数据
        console.log(res.timeStamp); // 客户端拿到缓存数据的时间戳
      },
    });
  },
});
```

## 数据分析

自定义分析数据上报接口。使用前，需要在小程序管理后台自定义分析中新建事件，配置好事件名与字段。具体参考[数据分析](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/data-analysis/wx.reportAnalytics.html)。

## 小程序登录

小程序的登录和普通应用的登录还是有区别的，因为小程序运载在微信上，其实已经有了当前用户的上下文，所以这里所谓的登录更倾向于是授权获取用户信息。云开发登录和传统登录有很大区别，云开发登录流程更简单，下面来对比下区别，

传统登录，参考[这里](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html)。先通过 wx.login 获取用户的临时凭证 code，调用后台接口传递 code，后台把 code 和静态保存的 appId、appSecret 传递给微信后台服务获取当前用户的 openId 和 session_key，后台存储到数据库并生成自定义登录凭证 userid（避免暴露 openId 给小程序前端）返给小程序前端。

云开发登录，参考[这里](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/userinfo.html)，在云函数中直接能够获取用户上下文信息，比如 openId 等。

对比可以看出，云开发登录独特优势在于与微信登录鉴权的无缝整合。当小程序端调用云函数时，可以直接通过 cloud.getWXContext 获取 openId、appId 等上下文信息，并且自定义登录凭证 userid 也没有存在的必要，小程序前端调用云函数也无需传递任何当前用户的凭证。

### FAQ

- wx.login 和 wx.getUserInfo 的关联？

wx.login 接口是静默进行的，也就是说，不会弹出授权窗口，通常用于自己服务后台的自定义登录态，调用成功后会返回一个 code，小程序前端把得到的 code 传给自己服务后台，自己后台结合 AppId+AppSecret 从微信服务接口获取 openId、session_key 信息，并生成自定义的用户标识，比如 UserId（因为官方出于安全考虑不推荐把 open_id 等参数暴露给前端），这样之后的接口直接传递 UserId 就可以了。

wx.getUserInfo 接口会发起用户授权，获取用户信息，这不会经过自己服务后台，相对于 wx.login 后再调用自己后台的获取用户接口来的更方便，它不用和 wx.login 绑定使用。

- 哪些数据库操作可以放在小程序前端，哪些放在云函数上？

- 在生命周期上 setData 的重绘问题
